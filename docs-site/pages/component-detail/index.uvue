<template>
  <doc-layout :sidebar-groups="sidebarGroups" :show-sidebar="true" :show-toc="true" :toc-items="tocItems">
    <view class="component-detail-content">
      <view v-if="doc && markdownContent" class="doc-wrapper">
        <markdown-renderer :content="markdownContent"></markdown-renderer>
      </view>

      <view class="loading" v-else-if="loading">
        <text class="loading-text">åŠ è½½ä¸­...</text>
      </view>

      <view class="error" v-else-if="error">
        <text class="error-text">{{ error }}</text>
      </view>
    </view>
  </doc-layout>
</template>

<script setup lang="uts">
import { ref, onMounted, computed } from 'vue'
import { loadComponentDoc, type ComponentDoc } from '@/utils/doc-loader'
import { componentsSidebar, type SidebarGroup } from '@/utils/sidebar-config'

const doc = ref<ComponentDoc | null>(null)
const markdownContent = ref<string>('')
const loading = ref(true)
const error = ref<string>('')

const sidebarGroups = computed(() => {
  return componentsSidebar
})

const tocItems = computed(() => {
  // ä» markdown å†…å®¹ä¸­æå–æ ‡é¢˜ä½œä¸ºç›®å½•
  if (!markdownContent.value) return []
  
  const items: Array<{ id: string; text: string; level: number }> = []
  const lines = markdownContent.value.split('\n')
  
  for (const line of lines) {
    const headingMatch = line.match(/^(#{1,6})\s+(.+)$/)
    if (headingMatch != null) {
      const level = headingMatch[1].length
      const text = headingMatch[2].trim()
      const id = text
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .trim()
      items.push({ id, text, level })
    }
  }
  
  return items
})

onMounted(async () => {
  // è·å–ç»„ä»¶åç§°
  // #ifdef APP || H5
  const pages = getCurrentPages()
  let componentName: string = ''
  if (pages != null && pages.length > 0) {
    const currentPage = pages[pages.length - 1]
    const options = currentPage.options || {}
    const name = options.name as string | null
    if (name != null && name != '') {
      const decoded = decodeURIComponent(name)
      if (decoded != null) {
        componentName = decoded
      }
    }
  }
  // #endif
  
  if (!componentName) {
    error.value = 'æœªæŒ‡å®šç»„ä»¶åç§°'
    loading.value = false
    return
  }

  try {
    // åŠ è½½æ–‡æ¡£
    const componentDoc = await loadComponentDoc(componentName)
    if (componentDoc != null) {
      doc.value = componentDoc
      
      // åŠ è½½å®Œæ•´çš„ Markdown å†…å®¹
      await loadMarkdownContent(componentName)
    } else {
      error.value = 'æœªæ‰¾åˆ°ç»„ä»¶æ–‡æ¡£'
    }
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : String(e)
    error.value = `åŠ è½½æ–‡æ¡£å¤±è´¥: ${errorMsg}`
  } finally {
    loading.value = false
  }
})

async function loadMarkdownContent(componentName: string) {
  try {
    // ä» uni_modules ç»„ä»¶ç›®å½•åŠ è½½ README.md
    const path = `/uni_modules/belay-unix/components/${componentName}/README.md`
    
    let content = ''
    
    try {
      const response = await fetch(path, {
        headers: {
          'Accept': 'text/plain, text/markdown, */*'
        }
      })
      
      if (response != null && response.ok) {
        const text = await response.text()
        // æ£€æŸ¥è¿”å›çš„æ˜¯å¦æ˜¯ HTMLï¼ˆè¯´æ˜è¢«é‡å®šå‘åˆ°äº† index.htmlï¼‰
        if (text.trim().startsWith('<!DOCTYPE') || text.includes('<html') || text.includes('<meta charset')) {
          console.error(`è·¯å¾„ ${path} è¿”å›äº† HTML è€Œä¸æ˜¯ Markdown`)
          throw new Error('è¿”å›äº† HTML è€Œä¸æ˜¯ Markdown')
        }
        content = text
        console.log(`æˆåŠŸåŠ è½½æ–‡æ¡£: ${path}`)
      } else if (response != null) {
        console.warn(`æ— æ³•åŠ è½½æ–‡æ¡£ (${response.status}): ${path}`)
        throw new Error(`HTTP ${response.status}`)
      } else {
        throw new Error('å“åº”ä¸ºç©º')
      }
    } catch (e) {
      console.error(`åŠ è½½æ–‡æ¡£å¤±è´¥: ${path}`, e)
      throw e
    }
    
    if (content) {
      // å¤„ç† Markdown å†…å®¹
      content = processMarkdownContent(content)
      markdownContent.value = content
    } else {
      // å¦‚æœæ²¡æœ‰æ‰¾åˆ° Markdown æ–‡ä»¶ï¼Œç”ŸæˆåŸºç¡€å†…å®¹
      markdownContent.value = generateBasicMarkdown(doc.value!)
    }
  } catch (e) {
    console.error('åŠ è½½ Markdown å¤±è´¥:', e)
    markdownContent.value = generateBasicMarkdown(doc.value!)
  }
}

function processMarkdownContent(content: string): string {
  // ä¿ç•™ ClientOnly å’Œ ExamplePreviewï¼Œè®©è§£æå™¨å¤„ç†
  // åªç§»é™¤ script setup æ ‡ç­¾æœ¬èº«ï¼ˆå†…å®¹å·²æå–ï¼‰
  return content
    .replace(/<script setup>[\s\S]*?<\/script>/g, '')
}

function generateBasicMarkdown(doc: ComponentDoc): string {
  return `# ${doc.title}

${doc.description || ''}

## ğŸ“¦ å¼•å…¥

\`\`\`typescript
import { ${doc.name.replace('bl-', '').split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('')} } from '@/uni_modules/belay-unix'
\`\`\`

æˆ–è€…ä½¿ç”¨å…¨å±€æ³¨å†Œï¼š

\`\`\`typescript
// main.uts æˆ– main.js
import BelayUnix from '@/uni_modules/belay-unix'
app.use(BelayUnix)
\`\`\`
`
}
</script>

<style lang="scss">
.component-detail-content {
  width: 100%;
}

.doc-wrapper {
  width: 100%;
}

.loading,
.error {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  padding: 40px;
}

.loading-text,
.error-text {
  font-size: 16px;
  color: #999;
}

.error-text {
  color: #f56c6c;
}
</style>

